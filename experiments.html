<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Experiments</title>

  <script src="vue.js"></script>
</head>

<body>

  <div id="app">

    <h2>Once and Vue Methods</h2>

    <input type="text" v-on:input="changeTitle">
    <p v-once>Once title: {{ title }}</p>
    <p>Dynamic Title: {{ title }}</p>
    <p>Click <a v-bind:href="link" target="blank">here!</a>
    </p>

    <hr>
    <h2>Events</h2>

    <p v-html="finishedLink"></p>
    <hr>
    <p>DOM Event Triggered: {{ event }}</p>
    <p>{{ counter }}</p>
    <button v-on:click="incrementCounter($event, 2)">
      Increment counter!
    </button>

    <hr>
    <h2>Event Modifiers</h2>

    <p v-on:mousemove="updateCoordinates">
      Coordinates: {{x}} / {{ y }}
      <!-- <span v-on:mousemove="dummy">DEAD SPOT</span> -->
      <span v-on:mousemove.stop>DEAD STOP</span>
    </p>
    <input type="text" v-on:keyup.enter.space="alertMe">

    <hr>
    <h2>Two-way-binding</h2>

    <input type="text" v-model="name">
    <p>{{ name }}</p>

    <!-- Computed Properties
         You can data-bind to computed properties in templates just like normal property.
         Vue is aware that vm.someProp depends on vm.someOtherProp, so it will update
         any binding that depend on vm.someOtherProp when vm.someProp changes. And the best
         part is that we've created this dependency relationship declaretively: the computed
         getter function has no side effects, which makes it easier to test and understand.

         Computed Caching and Methods
         Instead of a computed property, we can define the same function as a method instead. For
         the end result, the two approaches are indeed exactly the same. However, the diffence
         is that computed properties are cached based on their dependencies. A computed property
         will only re-evaluate when some of its dependencies have changed. This means as long as
         someOtherProp has not changed, multiple access to the someProp computed property will
         immediately return the previously computed result without having to the run function again.
    -->

    <hr>
    <h2>Computed</h2>

    <div>
      <p>Counter related to the computed output: {{ counter }}</p>
      <button v-on:click="counter--"><</button>
      <button v-on:click="counter++">></button>
      <p>Counter unralated to the computed output: {{ secondCounter }}</p>
      <button v-on:click="secondCounter--"><</button>
      <button v-on:click="secondCounter++">></button>
      <p>result(): {{ result() }} | This method will be called every render.</p>
      <p>output: {{ output }} | This method its linked with counter and it will be called just if the counter change.</p>
    </div>

    <hr>
    <h2>Watch</h2>

    <hr>
    <h2>Shortcuts</h2>

    <div>
      <button @click="counter++">Increment!</button> <!-- instead of v-on -->
      <a :href="link"></a> <!-- instead of v-bind-->
    </div>

    <hr>
    <h2>Styles and Classes</h2>
    <div>
        <!-- Vue.js will merge these two classes below -->
        <div class="demo" @click="attachRed = !attachRed" :class="divClasses"></div>
        <div class="demo" :class="{ red: attachRed }"></div>
        <div class="demo" :class="divClasses"></div>
        <div class="demo" :class="color"></div>
        <div class="demo" :class="[color, { red: attachRed }]"></div>
        <p>Color:</p>
        <input type="text" v-model="color">
      </div>

      <div>
        <div class="demo" :style="{ backgroundColor: color }"></div>
        <div class="demo" :style="{ 'background-color': color }"></div>
        <div class="demo" :style="myStyle"></div>
        <div class="demo" :style="[ myStyle, { height: `${ width } px` } ]"></div>
        <p>Width:</p>
        <input type="text" v-model="width">
      </div>

  </div>

  <script>

    /* Events
       preventDefault() method tells the user agent that if the event does not get explicitly
       handled, its default action should not be taken as it normally would be. The event continues
       to propagate as usual, unless one of its event listeners calls stopPropagation()
       or stopImmediatePropagation(), either of which terminates propagation at once.
    */

    new Vue({
      el: '#app',
      data: {
        name: "Igor",
        event: "No events triggered yet.",
        counter: 0,
        secondCounter: 0,
        title: 'Hello World!',
        link: 'https://google.com',
        finishedLink: '<a href="https://google.com">Google</a>',
        x: 0,
        y: 0,
        log: "",
        attachRed: false,
        color: 'green',
        width: 100
      },
      computed: {
        output() {
          console.log('output: Computed!');
          return this.counter > 5 ? 'Greater than 5' : 'Smaller than 5';
        },
        divClasses() {
          return {
            red: this.attachRed,
            blue: !this.attachRed
          };
        },
        myStyle() {
          return {
            backgroundColor: this.color,
            width: this.width + 'px'
          };
        }
      },
      methods: {
        alertMe() {
          alert('Alert');
        },
        changeTitle(e) {
          this.event = e;
          this.title = e.target.value;
        },
        sayHello() {
          this.title = "Hello!";
          return 'Hello!';
        },
        incrementCounter(e, step) {
          this.counter += step || 1;
        },
        updateCoordinates(e) {
          this.x = e.clientX;
          this.y = e.y;
        },
        dummy(e) {
          e.stopPropagation();
        },
        result() {
          console.log('result: Method!');
          return this.counter > 5 ? 'Greater than 5' : 'Smaller than 5';
        }
      },
      watch: {
        counter(value) {
          setTimeout(() => {
            this.counter = 0;
          }, 2000);
        }
      }
    });
  </script>

<style>
    .demo {
      width: 100px;
      height: 100px;
      background-color: gray;
      display: inline-block;
      margin: 10px;
    }

    .red {
      background-color: red;
    }

    .blue {
      background-color: blue;
    }

    .green {
      background-color: green;
    }
  </style>

</body>

</html>